{"posts":[{"title":"内存布局与启动流程","content":" 如上图所示，一般除了0xA00000到0xFFFFF(640K到1M共384K)和0xFFFE0000到0xFFFFFFF(4G最后的64K)以外的内存都可用作系统内存。[0x0, 0xA0000)的640K内存用于存放内核代码和数据，640K到1M即[0xA0000, 0x100000)保留用作图中的作用。由于Linux除了引导代码外不使用BIOS功能，也不使用BIOS中断向量表，因此存放在0x0到0x500的BIOS数据会被Linux系统模块覆盖。 如上图所示为Linux的引导扇区代码执行流程： 1、首先CPU在上电后会将0号扇区的512字节读到内存0x7C00开始的内存中，然后跳转到0x7C00执行引导代码（即bootsect.S） 2、bootsect.S会将自身重新拷贝至0x90000内存，然后跳到0x90000开始段中对应的位置继续执行。接着将1号扇区开始的4个扇区的代码（即setup.S）拷贝到0x90200处，将系统模块拷贝至0x10000内存处，然后跳到0x90200执行setup.S代码。 3、前面为什么要拷贝至0x90000呢？因为Linux0.12系统模块默认不超过512K，为了给其留足空间，bootsect.S从0x90000开始，这样从0x10000到0x90000刚好512K内存，足够后面拷贝系统模块。 4、setup.S会为系统设置好必要的硬件参数，然后将0x10000处开始的系统模块代码重新拷贝至0x0内存处，接着设置好临时gdt和idt表、打开保护模式，最后跳往0x0处开始执行32位系统模块头部代码（即head.s）。 5、这里又要问，为什么一开始不直接拷贝到0地址处，而是先拷贝到0x10000后再拷贝到0x0，这是因为在setup.S中设置系统所需的必要的硬件参数需要调用BIOS中断获取，而BIOS中断向量表就存放在0地址处，因此这时候还不能直接拷贝系统模块至0地址，只有等参数初始化完成后才能拷贝到0地址处。 ","link":"https://blog.sxhome.club/post/nei-cun-bu-ju-yu-qi-dong-liu-cheng/"},{"title":"16位x86汇编：int $0x10 显示中断","content":"int $0x10是BIOS显示功能的中断 功能号ah=0x03:读光标位置(用于设置参数寄存器为当前光标位置) 参数：bh = 页号 返回： ch:cl=扫描开始线:扫描结束线 dh:dl=行号(0x00 顶端):列号(0x00 最左边) 功能号ah=0x13:显示字符串 参数： ah:al=功能号:放置光标的方式及规定属性.0x01表示使用bl中的属性值,光标停在字符串结尾处 es:bp=此寄存器对指向要显示的字符串起始位置处 cx=显示的字符串字符数 bh:bl=显示页面号: 字符属性 dh:dl=行号:列号 字符属性: (0x00白色, 0x0a绿色, 0x0b水蓝, 0x0c红色, 0x0d紫色, 0x0e黄色) print_nl: # 打印换行 movw $0xe0d,%ax # CR int $0x10 movb $0xa,%al # LF int $0x10 ret print: push %bp # 保存bp movw %sp,%bp # 平衡堆栈 movb $0x03,%ah xorb %bh,%bh int $0x10 # 读光标位置到各参数寄存器，这样后面就会接在光标后继续打印 movw 4(%bp), %bp # 第一个压栈的参数为字符的地址 movw $0x10,%cx # 字符数 movw $0x1301,%ax # 0x13显示字符功能号 0x01使用bl属性值，光标停在结尾处 movw $0xc,%bx # 0x00页面 0x0c属性(红色) int $0x10 pop %bp # 恢复bp ret # 打印十六进制数，参数存在 ax 中 print_hex: mov $4,%cx mov %ax,%dx print_digit: rol $4,%dx mov $0xe,%ah mov %dl,%al and $0xf,%al add $0x30,%al cmp $0x39,%al jbe good_digit add $0x41-0x30-0xa,%al good_digit: int $0x10 loop print_digit ret ","link":"https://blog.sxhome.club/post/16-wei-x86-hui-bian-int-dollar0x10/"},{"title":"16位x86汇编：int $0x13 读磁盘中断","content":"int 0x13是BIOS读磁盘中断 参数： dh:dl=磁头号:驱动器号(硬盘则位7要置1) ch:cl=磁道(柱面号)的低8位:开始扇区(0-5)磁道号高2位(位6-7) 注意扇区号从1号开始 es:bx=读至的内存地址(如果出错则CF标志置位jnc指令可判断,ah中是出错码) ah:al=服务号 (0x02号服务为读磁盘扇区到内存):扇区数 ok_load_setup: xorw %dx, %dx # drive 0, head 0 (dx=磁头号:驱动器号) movw $0x02,%cx # sector 2, track 0 (cx=柱面号:开始扇区) movw #0x0200,%bx # (es:bx=内存地址=0x90200) movw %ax,#0x0200+len # 2号服务为读磁盘, int $0x13 # BIOS读磁盘中断 jnc ok_load_setup # jnc表示cf置位则跳转，cf置位则读磁盘失败，重读 ","link":"https://blog.sxhome.club/post/16-wei-hui-bian-int-0x13/"},{"title":"16位x86汇编：循环拷贝","content":"movw $0x7c0,%ax movw %ax,%ds movw $0x9000,%ax movw %ax,%es movw $256,%cx # 256字=512字节 sub %si,%si sub %di,%di rep movsw ljmp $0x9000,$offset 从[ds:si]拷贝%cx字（1字=2字节）到[es:di] ","link":"https://blog.sxhome.club/post/16-wei-hui-bian-xun-huan-kao-bei/"},{"title":"第一篇博客","content":"今天是我的生日，也是博客建站的第一天，愿以后和宝贝能够每天都在一起😊 ","link":"https://blog.sxhome.club/post/di-yi-pian-bo-ke/"}]}